#lang slideshow

(require 2htdp/universe 2htdp/image racket/draw)

(define ROWS 5)
(define COLS 5)

(define CELL-WIDTH 100)
(define CELL-PADDING 5)

(define FLOWER-SHADES 5)

(define FRAMES-PER-SEC 10)

(define EMPTY-SPOT "{ }")

; DIRECTION
(define AHEAD 0)
(define EAST 90)
(define FULL-CIRCLE 360)
(define HALF-CIRCLE 180)
(define HALF-LEFT -45)
(define HALF-RIGHT 45)
(define LEFT -90)
(define NORTH 0)
(define NORTHEAST 45)
(define NORTHWEST 315)
(define RIGHT 90)
(define SOUTH 180)
(define SOUTHEAST 135)
(define SOUTHWEST 225)
(define WEST 270)

(define (make-grid)
  (define (recur text count)
    (cond ((= count 0) (set! grid text))
          (else (recur (string-append text (make-string COLS #\*) "\n") (- count 1)))))
  (recur (string) ROWS))

; HELPERS
(define (between x a b) ; inclusive
  (and (>= x a) (<= x b)))
(define (repeated fn n) ; one-argument methods
  (λ (x) (cond ((= n 0) x)
                    (else (fn ((repeated fn (- n 1)) x))))))
(define (sqr x) (* x x))
(define (repeat fn n)
  (cond ((> n 0)
         (fn)
         (repeat fn (- n 1)))))
(define (increment n)
  (+ n 1))
(define (decrement n)
  (- n 1))
(define (all l) ; returns true if all parts of list evaluate to true
  (cond ((null? l) #t)
        ((equal? (car l) #f) #f)
        (else (all (cdr l)))))
(define (all2 l) ; returns true if all parts of list evaluate to true
  (define (recur l bool) ; NO short-circuit logic (might be needed in testing suite where side effects occur in the tested methods)
    (cond ((null? l) bool)
          ((equal? (car l) #f) (recur (cdr l) #f))
          (else (recur (cdr l) bool))))
  (recur l #t))
(define (pprint obj) ; pretty print (calls obj's to-string method)
  (display (obj 'to-string)))
(define (pluralize word num [plural (string-append (new-string word) "s")])
  (cond ((= num 1) word)
        (else (new-string plural)))) ; includes 0 (e.g. 0 dogs)
(define (range n) ; creates a list (n, 0]
  (cond ((> n 0) (cons (- n 1) (range (- n 1))))
        (else (list))))
(define wait sleep) ; wait x seconds
  
; SYNTAX
(define-syntax try ; (taken from: http://stackoverflow.com/questions/1557854/how-does-pltscheme-catch-errors)
  (syntax-rules (catch finally)
    ((_ try-body ... (catch catch-proc))
     (with-handlers (((λ (ex) #t)
              (λ (ex) 
                (catch-proc ex))))
            (begin
              try-body ...)))
    ((_ try-body ... (catch catch-proc) (finally fin-body ...))
     (dynamic-wind
     (λ () ())

     (λ ()
       (with-handlers (((λ (ex) #t)
                    (λ (ex) 
                      (catch-proc ex))))
                  (begin
                    try-body ...)))

     (λ () fin-body ...)))
    ((_ try-body ... (finally fin-body ...))
     (dynamic-wind
     (λ () ())

     (λ () try-body ...)

     (λ () fin-body ...)))))

; ERRORS
(define (error-array-out-of-bounds i min max) (error (string-append "ERROR: Array out of bounds ( [" (new-string min) ", " (new-string max) "] )\n\t" "Index: " (new-string i))))
(define (error-method-undefined m) (error (string-append "ERROR Method undefined\n\t" "Undefined method: " (new-string m))))
(define (error-test . args) (error (apply string-append "TEST ERROR:" args)))
(define (error-actor-not-in-grid a) (error (string-append "ERROR: " (new-string a) " not contained in grid.")))

; STRING
(define (new-string obj) ; returns an string (not a symbol)
  (cond ((number? obj) (number->string obj))
        ((symbol? obj) (symbol->string obj))
        ((char? obj) (string obj))
        ((boolean? obj) (cond (obj "#t") (else "#f")))
        ((string? obj) obj)
        ((empty? obj) "")
        (else (obj 'to-string))))

; ARRAY LIST
(define (new-array-list)
  (define array (list))
  (define (add element)
    (set (length array) element))
  (define (add2 index element)
    (define (recur l)
      (cond ((and (null? l) (= index (length array))) (list element))
            ((null? l) (list))
            ((eq? (+ (length l) index) (length array)) (cons element (cons (car l) (recur (cdr l)))))
            (else (cons (car l) (recur (cdr l))))))
    (cond ((between index 0 (length array)) (set! array (recur array)))
          (else (error-array-out-of-bounds index 0 (length array)))))
  (define (set index element)
    (define (recur l)
      (cond ((and (null? l) (= index (length array))) (list element))
            ((null? l) (list))
            ((eq? (+ (length l) index) (length array)) (cons element (recur (cdr l))))
            (else (cons (car l) (recur (cdr l))))))
    (cond ((between index 0 (length array)) (set! array (recur array)))
          (else (error-array-out-of-bounds index 0 (length array)))))
  (define (get index)
    (cond ((between index 0 (- (length array) 1)) (list-ref array index))
          (else (error-array-out-of-bounds index 0 (- (length array) 1)))))
  (define (remove index)
    (define (recur l)
      (cond ((null? l) (list))
            ((eq? (+ (length l) index) (length array)) (recur (cdr l)))
            (else (cons (car l) (recur (cdr l))))))
    (cond ((between index 0 (- (length array) 1)) (set! array (recur array)))
          (else (error-array-out-of-bounds index 0 (- (length array) 1)))))
  (define (for-each-iterator fn)
    (for-each fn array))
  (define (size)
    (length array))
  (define (contains element)
    (if (member element array)
        #t
        #f))
  (define (is-empty?)
    (= (size) 0))
  (define (to-string)
    (if (> (length array) 0)
        (string-append "{" (new-string (car array))
                       (if (> (length (cdr array)) 0)
                           (foldr (λ (e1 e2) 
                                    (string-append ", " (new-string e1) (new-string e2)))
                                  (list)
                                  (cdr array))
                           "")
                       "}")
        "{}"))
  (define (get-array)
    array)
  (define (dispatch m . args)
    (cond ((eq? m 'add) (apply (cond ((> (length args) 1) add2) (else add)) args))
          ((eq? m 'set) (apply set args))
          ((eq? m 'get) (apply get args))
          ((eq? m 'remove) (apply remove args))
          ((eq? m 'size) (apply size args))
          ((eq? m 'for-each) (apply for-each-iterator args))
          ((eq? m 'contains?) (apply contains args))
          ((eq? m 'is-empty?) (apply is-empty? args))
          ((eq? m 'to-string) (apply to-string args))
          ((eq? m 'get-array) (apply get-array args))
          (else (error-method-undefined m))))
  dispatch)

; TWO-DIMENSIONAL ARRAY
(define (new-2d-array rows cols . rest)
  (define array (new-array-list))
  (define (make-custom-array num)
    (repeat (λ () 
              (array 'add
                     (let ((row (new-array-list)))
                       (repeat (λ () 
                                 (row 'add num))
                               cols)
                       row)))
            rows))
  (define (make-array)
    (make-custom-array 0))
  (define (set x y element)
    ((array 'get x) 'set y element))
  (define (get x y)
    ((array 'get x) 'get y))
  (define (row-count) rows)
  (define (col-count) cols)
  (define (for-each-row-iterator fn)
    (array 'for-each (lambda (row) (fn row))))
  (define (for-each-iterator fn)
    (array 'for-each (lambda (row) (for-each fn (row 'get-array)))))
  (define (to-string)
    (array 'to-string))
  (define (dispatch m . args)
    (cond ((eq? m 'set) (apply set args))
          ((eq? m 'get) (apply get args))
          ((eq? m 'row-count) (apply row-count args))
          ((eq? m 'col-count) (apply col-count args))
          ((eq? m 'for-each-row) (apply for-each-row-iterator args))
          ((eq? m 'for-each) (apply for-each-iterator args))
          ((eq? m 'to-string) (apply to-string args))
          (else (error-method-undefined m))))
  (cond ((> (length rest) 0) (apply make-custom-array rest))
        (else (make-array)))
  dispatch)

; HASH MAP (taken from exercise 3.25 of SICP)
; todo add more features (or is the implementation already too general?)
; todo fix to-string method
(define (new-map)
  (define table (mcons '*table* '()))
  (define (assoc key records)
    (let ((mcaar (λ (x) (mcar (mcar x)))))
      (cond ((null? records) #f)
            ((equal? key (mcaar records)) (mcar records))
            (else (assoc key (mcdr records))))))
  (define (get key) (lookup table key))
  (define (put key value) (insert! table key value))
  (define (lookup t key)
    (let ((record (assoc key (mcdr t))))
      (cond (record (mcdr record))
            (else #f))))
  (define (insert! t key value)
    (let ((record (assoc key (mcdr t))))
      (cond (record (set-mcdr! record value))
            (else (set-mcdr! t
                             (mcons (mcons key value)
                                    (mcdr t)))))))
  (define (for-each-iterator fn)
    (define (recur t)
      (let ((mcaar (λ (x) (mcar (mcar x))))
            (mcdar (λ (x) (mcdr (mcar x)))))
        (cond ((and (not (null? t)) (not (mpair? (mcar t)))) (recur (mcdr t)))
              ((not (null? t))
               (begin
                 (fn (mcaar t) (mcdar t))
                 (recur (mcdr t)))))))
    (recur table))
  (define (contains? key)
    (get key))
  (define (empty?)
    (equal? table (mcons '*table* '())))
  (define (to-string)
    table)
  (define (dispatch m . args)
    (cond ((eq? m 'get) (apply get args))
          ((eq? m 'put) (apply put args))
          ((eq? m 'for-each) (apply for-each-iterator args))
          ((eq? m 'contains?) (apply contains? args))
          ((eq? m 'is-empty?) (apply empty? args))
          ((eq? m 'to-string) (to-string))
          (else (error-method-undefined m))))
  dispatch)

(define ACTOR-UI-MAPPINGS (new-map))
(ACTOR-UI-MAPPINGS 'put null EMPTY-SPOT)
(ACTOR-UI-MAPPINGS 'put "Actor" " A ")
(ACTOR-UI-MAPPINGS 'put "Bug" " B ")
(ACTOR-UI-MAPPINGS 'put "Rock" " R ")
(ACTOR-UI-MAPPINGS 'put "BoxBug" " BB ")
(ACTOR-UI-MAPPINGS 'put "ChameleonCritter" " ChC ")
(ACTOR-UI-MAPPINGS 'put "CrabCritter" " CrC ")
(ACTOR-UI-MAPPINGS 'put "Critter" " C ")
(ACTOR-UI-MAPPINGS 'put "Flower" " F ")

(define ACTOR-IMAGE-MAPPINGS (new-map))
(ACTOR-IMAGE-MAPPINGS 'put "Actor" (read-bitmap "images/actor.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "Bug" (read-bitmap "images/Bug.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "Rock" (read-bitmap "images/Rock.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "BoxBug" (read-bitmap "images/BoxBug.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "ChameleonCritter" (read-bitmap "images/ChameleonCritter.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "CrabCritter" (read-bitmap "images/CrabCritter.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "Critter" (read-bitmap "images/Critter.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "Flower1" (read-bitmap "images/Flower1.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "Flower2" (read-bitmap "images/Flower2.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "Flower3" (read-bitmap "images/Flower3.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "Flower4" (read-bitmap "images/Flower4.gif"))
(ACTOR-IMAGE-MAPPINGS 'put "Flower5" (read-bitmap "images/Flower5.gif"))

; LOCATION
(define (new-location r c)
  (define (get-row) r)
  (define (get-col) c)
  (define (compare-to loc)
    (let ((row1 (get-row))
          (row2 (loc 'get-row)))
      (cond ((> row1 row2) 1)
            ((= row1 row2)
             (let ((col1 (get-col))
                   (col2 (loc 'get-col)))
               (cond ((> col1 col2) 1)
                     ((= col1 col2) 0)
                     (else -1))))
            (else -1))))
  (define (get-adjacent-location dir)
    (new-location
     (cond ((or (= dir SOUTHEAST) (= dir SOUTH) (= dir SOUTHWEST)) (+ r 1))
           ((or (= dir EAST) (= dir WEST)) r)
           (else (- r 1)))
     (cond ((or (= dir NORTHEAST) (= dir EAST) (= dir SOUTHEAST)) (+ c 1))
           ((or (= dir NORTH) (= dir SOUTH)) c)
           (else (- c 1)))))
  (define (equals loc)
    (= (compare-to loc) 0))
  (define (to-string)
    (string-append "{" (new-string (get-row)) ", " (new-string (get-col)) "}"))
  (define (dispatch m . args)
    (cond ((eq? m 'get-row) (apply get-row args))
          ((eq? m 'get-col) (apply get-col args))
          ((eq? m 'get-adjacent-location) (apply get-adjacent-location args))
          ((eq? m 'compare-to) (apply compare-to args))
          ((eq? m 'equals) (apply equals args))
          ((eq? m 'to-string) (apply to-string args))
          (else (error-method-undefined m))))
  dispatch)

; BOUNDED GRID
(define (new-grid rows cols)
  (define grid-v (new-2d-array rows cols EMPTY-SPOT)) ; visuals
  (define grid-d (new-2d-array rows cols null)) ; data
  (define (get-num-cols)
    cols)
  (define (get-num-rows)
    rows)
  (define (to-string2)
    (grid 'to-string))
  (define (to-string)
    (let ((output (string)))
      (let ((append-output (λ ([s1 ""] . s) (set! output (apply string-append output (new-string s1) s)))))
        (grid-v 'for-each-row (lambda (row) 
                              (let ((row-string (string)))
                                (row 'for-each (λ (elem) (append-output elem "  ")))
                                row-string)
                              (append-output "\n"))))
      output))
  (define (get loc)
    (grid-d 'get (loc 'get-row) (loc 'get-col)))
  (define (put loc obj)
    (grid-v 'set (loc 'get-row) (loc 'get-col) (ACTOR-UI-MAPPINGS 'get (cond ((not (null? obj)) (obj 'get-name)) (else obj))))
    (grid-d 'set (loc 'get-row) (loc 'get-col) obj))
  (define (remove loc) ; replaces obj at loc with null
    (let ((obj (get loc)))
      (put loc null)
      obj))
  (define (get-occupied-locations)
    (let ((locs (new-array-list)))
      (for-each (lambda (row) 
                  (for-each (λ (col)
                              (let ((loc (new-location row col)))
                                (cond ((not (null? (get loc))) (locs 'add loc)))))
                            (range cols)))
                (range rows))
      locs))
  (define (is-valid? loc)
    (and (between (loc 'get-row) 0 (- rows 1))
         (between (loc 'get-col) 0 (- cols 1))))
  (define (dispatch m . args)
    (cond ((eq? m 'get-num-cols) (apply get-num-cols args))
          ((eq? m 'get-num-rows) (apply get-num-rows args))
          ((eq? m 'to-string) (apply to-string args))
          ((eq? m 'get) (apply get args))
          ((eq? m 'put) (apply put args))
          ((eq? m 'remove) (apply remove args))
          ((eq? m 'get-occupied-locations) (apply get-occupied-locations args))
          ((eq? m 'is-valid?) (apply is-valid? args))
          (else (error-method-undefined m))))
  dispatch)

; ACTOR WORLD
(define (new-actor-world grid)
  (define (add loc occupant)
    (occupant 'put-self-in-grid grid loc))
  (define (add-random occupant)
    (occupant 'put-self-in-grid grid (new-location (random (grid 'get-num-rows)) (random (grid 'get-num-cols)))))
  (define (remove loc)
    (grid 'remove loc))
  (define (step t) ; updates grid data
    (let ((INTERVAL (round (/ 28 FRAMES-PER-SEC)))) ; example: FPS = 2; INTERVAL = 14 (update every 14 'real' frames to achieve a simulated 2 FPS)
      ; TODO only works well for numbers that are factors of 28; will not work for FPS > 28
      (cond ((and (> t 0) (= (modulo (modulo t 28) INTERVAL) 0)) ; will not update update data first interval (this allows user to see intitial conditions)
             ; first, retrieve all objects from grid and adds them to array...
             (let ((objs (new-array-list)))
               ((grid 'get-occupied-locations) 'for-each (λ (loc) (objs 'add (grid 'get loc))))
               ; ...then update them by calling their 'act' method
               (objs 'for-each (λ (obj) (obj 'act))))))
      ; (this ensures that no bugs arise when objects are deleted in the middle of updating the entire grid)
      (show)))
  (define (show) ; updates grid data
    ; HELPER FUNCTIONS
    (define (add-to-grid row col image grid [size 20]) ; TODO rename since this only RETURNS a grid with the added obj
      (overlay/align/offset "left" "top" grid (+ (* size col) 0) (+ (* size row) 0) (pad-to (scale-to image size))))
    (define (make-grid rows cols [size 20] [type "outline"] [color "black"])
      (define (repeat elem n)
        (cond ((= n 0) (list))
              (else (cons elem (repeat elem (- n 1))))))
      ; inspiration from http://docs.racket-lang.org/teachpack/2htdpimage.html
      (let* ([s (rectangle size size type color)]
             [r (apply beside (repeat s cols))])
        (apply above (repeat r rows))))
    (define g (make-grid 10 10))
    (define (scale-to image [size 18])
      (scale/xy (/ size (image-width image)) (/ size (image-height image)) image))
    (define (pad-to image [size 20])
      (let ((padding-x CELL-PADDING)
            (padding-y CELL-PADDING))
        (crop (- padding-x) (- padding-y) (+ (image-width image) (* 2 padding-x)) (+ (image-height image) (* 2 padding-y)) image)))
    
    ; DRAW GRID
    (let ((g (make-grid ROWS COLS CELL-WIDTH)))
      (define (recur row col)
        (cond ((< col 0) (recur (- row 1) (- (grid 'get-num-cols) 1)))
              ((>= row 0)
               (let ((loc (new-location row col)))
                 (let ((obj (grid 'get loc)))
                   (cond ((not (null? obj)) 
                          (set! g (add-to-grid (loc 'get-row) (loc 'get-col) (obj 'to-shape) g CELL-WIDTH))))
                   (recur row (- col 1)))))))
      (recur (- (grid 'get-num-rows) 1) (- (grid 'get-num-cols) 1))
      (place-image/align g 0 0 "left" "top" (empty-scene (* CELL-WIDTH COLS) (* CELL-WIDTH ROWS)))))
  (define (play . args)
    (animate step))
  (define (to-string)
    (grid 'to-string))
  (define (dispatch m . args)
    (cond ((eq? m 'add) (cond ((> (length args) 1) (apply add args)) (else (apply add-random args))))
          ((eq? m 'remove) (apply remove args))
          ((eq? m 'play) (apply play args))
          ((eq? m 'to-string) (apply to-string args))
          (else (error-method-undefined m))))
  dispatch)

; ACTOR
(define (new-actor [name "Actor"])
  (define my-name name)
  (define my-loc null)
  (define my-grid null)
  (define my-dir null)
  
  ; local vars
  (define flower-shade 1)
  
  (define (init)
    (set-direction NORTH))
  (define (act)
    (define (act-actor)
      (set-direction (+ my-dir HALF-CIRCLE)))
    (define (act-bug)
      (let ((loc (my-loc 'get-adjacent-location my-dir)))
        (cond ((and (my-grid 'is-valid? loc) (or (null? (my-grid 'get loc)) ((my-grid 'get loc) 'is-a? "Flower"))) 
               (let ((curr-loc my-loc))
                 (move-to loc)
                 (aw 'add curr-loc (new-actor "Flower"))))
              (else (set-direction (+ my-dir HALF-RIGHT))))))
    (define (act-rock)
      void)
    (define (act-flower) ; find a dynamic way to darken bitmap
      (set! flower-shade (cond ((>= flower-shade FLOWER-SHADES) FLOWER-SHADES)
                                   (else (+ flower-shade 1)))))
    (cond ((equal? my-name "Actor") (act-actor))
          ((equal? my-name "Bug") (act-bug))
          ((equal? my-name "Rock") (act-rock))
          ((equal? my-name "Flower") (act-flower))))
  (define (put-self-in-grid gr loc)
    (set! my-grid gr)
    (set! my-loc loc)
    (gr 'put loc dispatch))
  (define (remove-self-from-grid gr)
    (gr 'remove my-loc)
    (set! gr null)
    (set! my-loc null))
  (define (get-location) my-loc)
  (define (move-to loc)
    (cond ((null? my-grid) (error-actor-not-in-grid dispatch))
          (else (my-grid 'put loc dispatch)
                (my-grid 'remove my-loc)
                (set! my-loc loc))))
  (define (set-direction dir) 
    (set! my-dir (modulo dir FULL-CIRCLE)))
  (define (get-direction) my-dir)
  (define (get-grid) my-grid)
  (define (get-name) my-name)
  (define (to-string)
    (cond ((null? my-loc) my-name)
          (else (string-append "[" my-name " at " (new-string my-loc) "]"))))
  (define (to-shape)
    (cond ((equal? my-name "Flower")
           (rotate (- (get-direction)) (ACTOR-IMAGE-MAPPINGS 'get (string-append my-name (new-string flower-shade)))))
          (else
           (rotate (- (get-direction)) (ACTOR-IMAGE-MAPPINGS 'get my-name)))))
  (define (is-a? name)
    (cond ((equal? name "Actor") #t)
          (else (equal? name my-name))))
  (define (dispatch m . args)
    (cond ((eq? m 'act) (apply act args))
          ((eq? m 'put-self-in-grid) (apply put-self-in-grid args))
          ((eq? m 'remove-self-from-grid) (apply remove-self-from-grid args))
          ((eq? m 'get-location) (apply get-location args))
          ((eq? m 'move-to) (apply move-to args))
          ((eq? m 'set-direction) (apply set-direction args))
          ((eq? m 'get-direction) (apply get-direction args))
          ((eq? m 'get-grid) (apply get-grid args))
          ((eq? m 'get-name) (apply get-name args))
          ((eq? m 'to-string) (apply to-string args))
          ((eq? m 'to-shape) (apply to-shape args))
          ((eq? m 'is-a?) (apply is-a? args))
          (else (error-method-undefined m))))
  (init)
  dispatch)

; UNIT-TEST v2.0
; Summary - takes a procedure and desired outputs for a given set of arguments (arranged by test cases)
;         - returns true if all test cases passed, otherwise returns false and prints out failed test cases
;         - test cases are in the format '([desired output] [arg1] [arg2] [...])
; Example usage - 
;   (unit-test + '(7 1 5 1) '(3 1 4 -2)) --> #t
;   test cases:
;       7 ?= 1 + 5 + 1  --> true
;       3 ?= 1 + 4 - 2  --> true
;   
;   (unit-test + '(7 1 5 1) '(3 1 4 -1)) --> #f
;   test cases:
;       7 ?= 1 + 5 + 1  --> true
;       3 ?= 1 + 4 - 1  --> false
;
; Arguments   p - procedure
;             case1 - ( [desired output] . args)
;             etc. (only one test case is required)
(define (unit-test p . cases)
  (let ((pass? #t))
    (define (test . cases)
      (cond ((empty? cases) pass?)
            (else
             (let ((case-to-test (car cases)))
               (cond ((equal? (apply p (cdr case-to-test)) (car case-to-test))
                      (apply test (cdr cases)))
                     (else 
                      (display (format "The following test case failed:~n  Test data: ~a~n  Desired output: ~a~n  Actual output: ~a~n~n" (cdr case-to-test) (car case-to-test) (apply p (cdr case-to-test))))
                      (set! pass? #f)
                      (apply test (cdr cases))))))))
    (apply test cases)))
(define (error? p . cases)
  (not (apply unit-test p cases)))
(define (exception? p)
  (try
   (p)
   #f
   (catch (λ (ex)
            #t))))

; TESTING SUITE
(define (run-tests)
  (define errors (new-map))
  (define (make-error e category . rest) ; TODO eventually should support multiple categories
    (cond ((null? rest)
           (cond ((errors 'contains? category)
                  (let ((arr (new-array-list)))
                    (arr 'add (errors 'get category))
                    (arr 'add e)
                    (errors 'put category arr)))
                 (else (errors 'put category e))))
          (else (let ((m (new-map)))
                  (m 'put category e)
                  (make-error m rest)))))
  (define (print-errors)
    (let ((msg (string)))
      (let ((append-msg (λ ([msg1 ""] . msgs) (set! msg (apply string-append msg msg1 msgs)))))
        (errors 'for-each (λ (key value) 
                            (append-msg "\n\t" key " " (pluralize "test" (cond ((number? value) 1) 
                                                                               (else (value 'size)))) " " (new-string value) " failed")))
        (error-test msg))))
  (let ((category "HELPER"))
    (cond ((error? (λ (wd) (pluralize wd 2)) (list "dogs" 'dog) (list "dogs" "dog"))
           (make-error 1 category)))
    (cond ((error? (λ (wd) (pluralize wd 1)) '(dog dog) '("dog" "dog") '(0 0) (let ((arr (new-array-list))) (list arr arr)))
           (make-error 2 category)))
    (cond ((error? (λ (wd) (pluralize wd 0)) '("dogs" dog) '("dogs" "dog") '("1s" 1))
           (make-error 3 category)))
    (cond ((error? (λ (wd) (pluralize wd 3 'cries)) '("cries" cry) '("cries" "cry"))
           (make-error 4 category)))
    (cond ((error? (λ (wd) (pluralize wd 4 "cries")) '("cries" cry) '("cries" "cry"))
           (make-error 5 category)))
    (cond ((error? between '(#t 3 1 5) '(#f -1 1 5) '(#t -1 -2 0))
           (make-error 6 category)))
    (cond ((error? sqr '(0 0) '(1 1) '(4 2) '(9 -3))
           (make-error 7 category)))
    (cond ((error? (λ (n) ((repeated sqr 3) n)) '(1 1) '(256 2) '(1 -1) '(256 -2) '(0 0))
           (make-error 8 category))))
  (let ((category "ARRAY"))
    (cond ((let ((arr (new-array-list)))
             (arr 'add -1)
             (arr 'add 0)
             (arr 'add 1)
             (arr 'add 2)
             (arr 'set 0 -2)
             (arr 'set 1 -1)
             (arr 'remove 2)
             (arr 'add 2 0)
             (arr 'set 3 10)
             (arr 'add 4 11)
             (not (all (list
                        (= (arr 'size) 5)
                        (= (arr 'get 0) -2)
                        (= (arr 'get 1) -1)
                        (= (arr 'get 2) 0)
                        (= (arr 'get 3) 10)
                        (= (arr 'get 4) 11)
                        (not (arr 'is-empty?))
                        (arr 'contains? 10)
                        (not (arr 'contains? 4))))))
           (make-error 1 category)))
    (cond ((not (exception? (λ () ((new-array-list) 'get 2))))
           (make-error 2 category)))
    (cond  ((not (exception? (λ () ((new-array-list) 'set 1 2))))
            (make-error 3 category)))
    (cond  ((exception? (λ () ((new-array-list) 'set 0 1)))
            (make-error 4 category)))
    (cond  ((exception? (λ () (let ((arr (new-array-list)))
                                     (arr 'add 1)
                                     (arr 'get 0))))
           (make-error 5 category))))
  (let ((category "LOCATION"))
    (cond ((error? (λ (loc1 loc2) (loc1 'compare-to loc2)) (list 1 (new-location 1 1) (new-location 0 0)))
           (make-error 1 category)))
    (cond ((error? (λ (loc1 loc2) (loc1 'compare-to loc2)) (list 0 (new-location 0 0) (new-location 0 0)))
           (make-error 2 category)))
    (cond ((error? (λ (loc1 loc2) (loc1 'compare-to loc2)) (list -1 (new-location 0 0) (new-location 1 1)))
           (make-error 3 category)))
    (cond ((error? (λ (loc1 loc2) (loc1 'compare-to loc2)) (list -1 (new-location 0 0) (new-location 0 1)))
           (make-error 4 category)))
    (cond ((error? (λ (loc1 loc2) (loc1 'compare-to loc2)) (list 1 (new-location 0 1) (new-location 0 0)))
           (make-error 5 category)))
    (cond ((error? (λ (loc1 loc2) (loc1 'compare-to loc2)) (list -1 (new-location 0 0) (new-location 1 0)))
           (make-error 6 category)))
    (cond ((error? (λ (loc1 loc2) (loc1 'compare-to loc2)) (list 1 (new-location 1 0) (new-location 0 0)))
           (make-error 7 category))))
  (cond ((errors 'is-empty?) (display "All tests passed"))
        (else (print-errors))))
(run-tests)

; Set up GridWorld
(define grid (new-grid ROWS COLS))
(define g grid)
(define aw (new-actor-world g))
(aw 'add (new-location 3 1) (new-actor "Rock"))
(aw 'add (new-location 4 1) (new-actor "Rock"))
(aw 'add (new-actor "Flower"))
(aw 'add (new-actor "Actor"))
(aw 'add (new-actor "Bug"))
(aw 'play)
